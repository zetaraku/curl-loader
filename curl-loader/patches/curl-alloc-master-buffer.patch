diff -Naru curl-7.16.2/lib/sendf.c curl-7.16.2-mod/lib/sendf.c
--- curl-7.16.2/lib/sendf.c	2007-04-22 17:00:20.000000000 +0300
+++ curl-7.16.2-mod/lib/sendf.c	2007-04-22 16:56:11.000000000 +0300
@@ -495,7 +495,7 @@
     }
     /* If we come here, it means that there is no data to read from the buffer,
      * so we read from the socket */
-    bytesfromsocket = MIN(sizerequested, sizeof(conn->master_buffer));
+    bytesfromsocket = MIN(sizerequested, BUFSIZE * sizeof (char));
     buffertofill = conn->master_buffer;
   }
   else {
diff -Naru curl-7.16.2/lib/transfer.c curl-7.16.2-mod/lib/transfer.c
--- curl-7.16.2/lib/transfer.c	2007-04-22 17:00:20.000000000 +0300
+++ curl-7.16.2-mod/lib/transfer.c	2007-04-22 16:56:11.000000000 +0300
@@ -289,8 +289,13 @@
     size_t show;
 
     show = MIN(conn->buf_len - conn->read_pos, sizeof(buf)-1);
-    memcpy(buf, conn->master_buffer + conn->read_pos, show);
-    buf[show] = '\0';
+    if (conn->master_buffer) {
+        memcpy(buf, conn->master_buffer + conn->read_pos, show);
+        buf[show] = '\0';
+    }
+    else {
+        buf[0] = '\0';
+    }
 
     DEBUGF(infof(conn->data,
                  "Buffer after stream rewind (read_pos = %d): [%s]",
diff -Naru curl-7.16.2/lib/url.c curl-7.16.2-mod/lib/url.c
--- curl-7.16.2/lib/url.c	2007-04-22 17:00:20.000000000 +0300
+++ curl-7.16.2-mod/lib/url.c	2007-04-22 16:58:12.000000000 +0300
@@ -1805,6 +1805,8 @@
 
   Curl_free_ssl_config(&conn->ssl_config);
 
+  Curl_safefree(conn->master_buffer);
+
   free(conn); /* free all the connection oriented data */
 }
 
@@ -2825,7 +2827,7 @@
      to not have to modify everything at once, we allocate a temporary
      connection data struct and fill in for comparison purposes. */
 
-  conn = (struct connectdata *)calloc(sizeof(struct connectdata), 1);
+  conn = (struct connectdata *)calloc(1, sizeof(struct connectdata));
   if(!conn) {
     *in_connect = NULL; /* clear the pointer */
     return CURLE_OUT_OF_MEMORY;
@@ -2835,6 +2837,15 @@
      any failure */
   *in_connect = conn;
 
+  if (data->multi && Curl_multi_canPipeline(data->multi)) {
+      /* Allocate master_buffer to be used for pipelining */
+      if (!conn->master_buffer) {
+          if (!(conn->master_buffer = calloc(BUFSIZE, sizeof (char)))) {
+              return CURLE_OUT_OF_MEMORY;
+          }
+      }
+  }
+
   /* and we setup a few fields in case we end up actually using this struct */
 
   conn->data = data; /* Setup the association between this connection
@@ -3803,6 +3814,7 @@
     Curl_safefree(old_conn->proxypasswd);
     Curl_llist_destroy(old_conn->send_pipe, NULL);
     Curl_llist_destroy(old_conn->recv_pipe, NULL);
+    Curl_safefree(conn->master_buffer);
 
     free(old_conn);          /* we don't need this anymore */
 
diff -Naru curl-7.16.2/lib/urldata.h curl-7.16.2-mod/lib/urldata.h
--- curl-7.16.2/lib/urldata.h	2007-04-22 17:00:20.000000000 +0300
+++ curl-7.16.2-mod/lib/urldata.h	2007-04-22 16:56:11.000000000 +0300
@@ -868,7 +868,8 @@
   struct curl_llist *recv_pipe; /* List of handles waiting to read
                                    their responses on this pipeline */
 
-  char master_buffer[BUFSIZE]; /* The master buffer for this connection. */
+  char* master_buffer; /* The master buffer allocated on-demand; 
+                          used for pipelining. */
   size_t read_pos; /* Current read position in the master buffer */
   size_t buf_len; /* Length of the buffer?? */
 
